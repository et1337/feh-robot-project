#use "exp_servo_lib.ic"
#use "exp_servo_calibrate.ic"

#use "fencdr2.icb"
#use "fencdr3.icb"

#use "constants.ic"

void setEncoder(int port, int ticks)
{
    if(port == 2)
      encoder2_counts = ticks;
    else if(port == 3)
      encoder3_counts = ticks;
}

float inches(int ticks)
{
    return ((float)ticks / 24.0) * 6.283185307;
}

int ticks(float inches)
{
    return (int)((inches / 6.283185307) * 24.0);
}

int getEncoder(int port)
{
    if(port == 2)
      return encoder2_counts;
    else if(port == 3)
      return encoder3_counts;
}

void encoderCount(int port, int ticks)
{
    setEncoder(port, 0);
    while(getEncoder(port) < ticks);
}

void drive(int left, int right)
{
    motor(leftMotor, left);
    motor(rightMotor, right);
}

void turn(int ticks, int direction)
{
    switch(direction)
    {
        case FORWARD_RIGHT:
          drive(100, 0);
          encoderCount(leftEncoder, ticks);
        break;
        case FORWARD_LEFT:
          drive(0, 100);
          encoderCount(rightEncoder, ticks);
        break;
        case BACKWARD_RIGHT:
          drive(0, -100);
          encoderCount(rightEncoder, ticks);
        break;
        case BACKWARD_LEFT:
          drive(-100, 0);
          encoderCount(leftEncoder, ticks);
        break;
    }
    drive(0, 0);
}

void driveStraight(int distance, int direction)
{
    drive(100 * direction, 100 * direction);
    setEncoder(leftEncoder, 0);
    setEncoder(rightEncoder, 0);
    while(getEncoder(leftEncoder) < distance)
      {
        if(getEncoder(leftEncoder) < getEncoder(rightEncoder) - 1)
          drive(100 * direction, 50 * direction);
        else if(getEncoder(rightEncoder) < getEncoder(leftEncoder) - 1)
          drive(50 * direction, 100 * direction);
        else
        drive(100 * direction, 100 * direction);
    }
    drive(0, 0);
}

void driveStraightWaitForLine(int floorValue)
{
    drive(100, 100);
    setEncoder(leftEncoder, 0);
    setEncoder(rightEncoder, 0);
    while((analog(centerLinePort) < floorValue + LINE_THRESHOLD))
      {
        if(getEncoder(leftEncoder) < getEncoder(rightEncoder) - 1)
          drive(100, 50);
        else if(getEncoder(rightEncoder) < getEncoder(leftEncoder) - 1)
          drive(50, 100);
        else
        drive(100, 100);
    }
    drive(0, 0);
}

void driveStraightWaitForBump()
{
    drive(100, 100);
    setEncoder(leftEncoder, 0);
    setEncoder(rightEncoder, 0);
    while(!(digital(frontLeftSwitch) || digital(frontRightSwitch)))
      {
        if(getEncoder(leftEncoder) < getEncoder(rightEncoder) - 1)
          drive(100, 50);
        else if(getEncoder(rightEncoder) < getEncoder(leftEncoder) - 1)
          drive(50, 100);
        else
        drive(100, 100);
    }
    drive(0, 0);
}

int lineFollowState = LINE_FOLLOW_LEFT;
void followLine(int leftLineFloorValue, int centerLineFloorValue, int rightLineFloorValue)
{
    int left = (analog(leftLinePort) > leftLineFloorValue + LINE_THRESHOLD);
    int center = (analog(centerLinePort) > centerLineFloorValue + LINE_THRESHOLD);
    int right = (analog(centerLinePort) > rightLineFloorValue + LINE_THRESHOLD);
    
    if(center)
      {
        if(right)
          {
            drive(100, 60);
            lineFollowState = LINE_FOLLOW_RIGHT;
        }
        else if(left)
          {
            drive(60, 100);
            lineFollowState = LINE_FOLLOW_LEFT;
        }
        else
        {
            drive(100, 100);
        }
    }
    else if(left)
      {
        drive(0, 100);
        lineFollowState = LINE_FOLLOW_LEFT;
    }
    else if(right)
      {
        drive(100, 0);
        lineFollowState = LINE_FOLLOW_RIGHT;
    }
    else
      {
        if(lineFollowState == LINE_FOLLOW_RIGHT)
          drive(100, 0);
        else if(lineFollowState == LINE_FOLLOW_LEFT)
          drive(0, 100);
    }
}

void implement(int angle)
{
    exp_servo_deg(implementServo, angle);
}

void DropOffDynamite()
{
    // Drive down the ramp
    driveStraight(ticks(22.0), FORWARD);
    
    // Turn toward dynamite dropbox
    turn(ticks(7.6), FORWARD_LEFT);
    
    // Drive toward dropbox
    driveStraight(ticks(19.0), FORWARD);
    
    // Drop dynamite
    implement(IMPLEMENT_DOWN);
    sleep(1.0);
    implement(IMPLEMENT_UP);
}

void DepressPlunger(int leftLineFloorValue, int centerLineFloorValue, int rightLineFloorValue)
{
    // Back up a little
    driveStraight(ticks(7.0), BACKWARD);
    
    // Turn toward plunger
    turn(ticks(3.5), FORWARD_LEFT);
    
    // Drive toward plunger
    driveStraight(ticks(15.0), FORWARD);
    
    // Turn toward plunger to help the line-following routine
    turn(ticks(8.0), FORWARD_LEFT);
    
    leftLineFloorValue = analog(leftLinePort);
    centerLineFloorValue = analog(centerLinePort);
    rightLineFloorValue = analog(rightLinePort);
    
    // Drive toward plunger until we hit the second line
    driveStraightWaitForLine(centerLineFloorValue);
    
    lineFollowState = LINE_FOLLOW_LEFT;
    // Follow the line until we bump into the plunger
    while(!(digital(frontLeftSwitch) && digital(frontRightSwitch)))
    {
        followLine(leftLineFloorValue, centerLineFloorValue, rightLineFloorValue);
    }
    drive(0, 0);
    
    // Lower and raise the implement
    implement(IMPLEMENT_DOWN);
    sleep(1.0);
    implement(IMPLEMENT_UP);
}

void GetGem(int leftLineFloorValue, int centerLineFloorValue, int rightLineFloorValue)
{
    // Turn backwards and to the right; we're trying to turn 180 around and follow the line
    turn(ticks(22.0), BACKWARD_RIGHT);
    
    driveStraight(ticks(4.0), FORWARD);
    
    turn(ticks(4.0), FORWARD_RIGHT);
    
    leftLineFloorValue = analog(leftLinePort);
    centerLineFloorValue = analog(centerLinePort);
    rightLineFloorValue = analog(rightLinePort);
    driveStraightWaitForLine(centerLineFloorValue);
    
    lineFollowState = LINE_FOLLOW_RIGHT;

    
    // Follow the line up the ramp until we hit the gem
    while(!(digital(frontLeftSwitch) || digital(frontRightSwitch)))
    {
        followLine(leftLineFloorValue, centerLineFloorValue, rightLineFloorValue);
    }
    
    //driveStraightWaitForBump();
    
    // Stop
    drive(0, 0);
}

int main()
{
    int startLightValue = 0;
    int leftLineFloorValue;
    int centerLineFloorValue;
    int rightLineFloorValue;
    long startTime = 0L;
    
    exp_servo_enable();
    
    exp_servo_min[implementServo] = 2588;
    exp_servo_max[implementServo] = 4078;
    
    encoder2_low_threshold = 25;
    encoder2_high_threshold = 30;
    
    encoder3_low_threshold = 25;
    encoder3_high_threshold = 30;
    
    implement(IMPLEMENT_UP);
    
    startLightValue = analog(startLightPort);

    
    // Wait for start light or start button.
    while(!start_button())
    {
        sleep(0.1);
        if(knob() < 64)
        {
            printf("1 Plunger only\n");
        }
        else if(knob() < 128)
        {
            printf("2 Plunger and gem\n");
        }
        else if(knob() < 192)
        {
            printf("3 Gem only\n");
        }
        else
        {
            printf("4 Full routine\n");
            if(analog(startLightPort) < startLightValue - START_LIGHT_THRESHOLD)
              break;
        }
    }
    leftLineFloorValue = analog(leftLinePort);
    centerLineFloorValue = analog(centerLinePort);
    rightLineFloorValue = analog(rightLinePort);
    if(knob() < 64)
    {
        // Just do plunger
        DepressPlunger(leftLineFloorValue, centerLineFloorValue, rightLineFloorValue);
    }
    else if(knob() < 128)
    {
        // Do plunger and gem
        DepressPlunger(leftLineFloorValue, centerLineFloorValue, rightLineFloorValue);
        // Wait for debris ramp to fall
        sleep(1.0);
        GetGem(leftLineFloorValue, centerLineFloorValue, rightLineFloorValue);
    }
    else if(knob() < 192)
    {
        // Just do gem
        GetGem(leftLineFloorValue, centerLineFloorValue, rightLineFloorValue);
    }
    else
    {
        // Full routine
        DropOffDynamite();
        DepressPlunger(leftLineFloorValue, centerLineFloorValue, rightLineFloorValue);
        // Wait for debris ramp to fall
        sleep(1.0);
        GetGem(leftLineFloorValue, centerLineFloorValue, rightLineFloorValue);
    }

    exp_servo_disable();
}
