#include "constants_lib.ic"
#include "encoder_lib.ic"
#include "gps_lib.ic"
int lineFollowState = LINE_FOLLOW_LEFT;
int OnLine(int port, int value)
{
    return (analog(port) > value + LINE_THRESHOLD);
}
void drive(int left, int right)
{
    motor(leftMotor, left);
    motor(rightMotor, right);
}
void GPSTurn(int angle, int dir)
{
    int initial, final;
    // Wait for data
    printf("Turning...\n");
    while(!gps_get_data());
    initial = gps_heading;
    printf("Got data, initial = %d\n", initial);
    if (dir == LEFT) {
        drive(-100, 100);
        if (initial + angle > 180)
          {
            while (gps_heading > initial - 1) {
                printf("%d First\n", gps_heading);
                while(!gps_get_data());
            }
            while (gps_heading < (initial + angle - 180))
              {
                while(!gps_get_data());
                printf("%d Second\n", gps_heading);
            }
        } else
          while (gps_heading < initial + angle)
            {
              while (!gps_get_data());
              printf("heading=%d\n",gps_heading);
          }
    } else if (dir == RIGHT) {
        drive(100, -100);
        if (initial - angle < 0)
          {
            while (gps_heading < initial + 1) {
                printf("%d First\n", gps_heading);
                while(!gps_get_data());
            }
            while (gps_heading < (initial - angle + 180))
              {
                while(!gps_get_data());
                printf("%d Second\n", gps_heading);
            }
        } else
          while (gps_heading > initial - angle)
            {
              while (!gps_get_data());
              printf("heading=%d\n",gps_heading);
          }
    }
    drive(0,0);
}
void driveStraight(int distance, int direction)
{
    drive(100 * direction, 100 * direction);
    setEncoder(leftEncoder, 0);
    setEncoder(rightEncoder, 0);
    while(getEncoder(leftEncoder) < distance)
      {
        if(getEncoder(leftEncoder) < getEncoder(rightEncoder) - 1)
          drive(100 * direction, 50 * direction);
        else if(getEncoder(rightEncoder) < getEncoder(leftEncoder) - 1)
          drive(50 * direction, 100 * direction);
        else
        drive(100 * direction, 100 * direction);
    }
    drive(0, 0);
}

void driveStraightWaitForLine(int floorValue)
{
    drive(100, 100);
    setEncoder(leftEncoder, 0);
    setEncoder(rightEncoder, 0);
    while((analog(centerLinePort) < floorValue + LINE_THRESHOLD))
      {
        if(getEncoder(leftEncoder) < getEncoder(rightEncoder) - 1)
          drive(100, 50);
        else if(getEncoder(rightEncoder) < getEncoder(leftEncoder) - 1)
          drive(50, 100);
        else
        drive(100, 100);
    }
    drive(0, 0);
}
/*void driveStraightToX(int x)
{
    int initial;
    drive(100, 100);
    setEncoder(leftEncoder, 0);
    setEncoder(rightEncoder, 0);
    while(!gps_get_data());
    initial = gps_x;
    if (initial < x) {
        while(gps_x < x)
          {
            while(!gps_get_data());
            if(getEncoder(leftEncoder) < getEncoder(rightEncoder) - 1)
              drive(100, 50);
            else if(getEncoder(rightEncoder) < getEncoder(leftEncoder) - 1)
              drive(50, 100);
            else
            drive(100, 100);
        }
    } else {
        while(gps_x > x)
          {
            while(!gps_get_data());
            if(getEncoder(leftEncoder) < getEncoder(rightEncoder) - 1)
              drive(100, 50);
            else if(getEncoder(rightEncoder) < getEncoder(leftEncoder) - 1)
              drive(50, 100);
            else
            drive(100, 100);
            drive(0, 0);   
        }
    }
}*/
void driveStraightToY(int y)
{
    int initial;
    drive(100, 100);
    setEncoder(leftEncoder, 0);
    setEncoder(rightEncoder, 0);
    while(!gps_get_data());
    initial = gps_y;
    if (initial < y) {
        while(gps_y < y)
          {
            while(!gps_get_data());
            if(getEncoder(leftEncoder) < getEncoder(rightEncoder) - 1)
              drive(100, 50);
            else if(getEncoder(rightEncoder) < getEncoder(leftEncoder) - 1)
              drive(50, 100);
            else
            drive(100, 100);
        }
    } else {
        while(gps_y > y)
          {
            while(!gps_get_data());
            if(getEncoder(leftEncoder) < getEncoder(rightEncoder) - 1)
              drive(100, 50);
            else if(getEncoder(rightEncoder) < getEncoder(leftEncoder) - 1)
              drive(50, 100);
            else
            drive(100, 100);
        }
    }
    drive(0, 0);   
}
void HeadingToY(int y, int angle, int direction)
{
    int initial;
    drive(100, 100);
    setEncoder(leftEncoder, 0);
    setEncoder(rightEncoder, 0);
    while(!gps_get_data());
    initial = gps_y;
    if (initial < y) {
        while(gps_y < y)
          {
            while(!gps_get_data());
            if(gps_heading < angle - 2)
              drive(50 * direction, 100 * direction);
            else if(gps_heading < angle - 1)
              drive(80 * direction, 100 * direction);
            else if(gps_heading > angle + 2)
              drive(100 * direction, 50 * direction);
            else if(gps_heading > angle + 1)
              drive(100 * direction, 80 * direction);
            else
            drive(100 * direction, 100 * direction);
            
        }
    } else {
        while(gps_y > y)
          {
            while(!gps_get_data());
            if(gps_heading < angle - 2)
              drive(50 * direction, 100 * direction);
            else if(gps_heading < angle - 1)
              drive(80 * direction, 100 * direction);
            else if(gps_heading > angle + 2)
              drive(100 * direction, 50 * direction);
            else if(gps_heading > angle + 1)
              drive(100 * direction, 80 * direction);
            else
            drive(100 * direction, 100 * direction);
        }
    }
    drive(0, 0);   
}


void driveStraightWaitForBump()
{
    drive(100, 100);
    setEncoder(leftEncoder, 0);
    setEncoder(rightEncoder, 0);
    while(!(digital(frontLeftSwitch) || digital(frontRightSwitch)))
      {
        if(getEncoder(leftEncoder) < getEncoder(rightEncoder) - 1)
          drive(100, 50);
        else if(getEncoder(rightEncoder) < getEncoder(leftEncoder) - 1)
          drive(50, 100);
        else
        drive(100, 100);
    }
    drive(0, 0);
}

/*void followLine(int leftLineFloorValue, int centerLineFloorValue, int rightLineFloorValue)
{
    int left = (analog(leftLinePort) > leftLineFloorValue + LINE_THRESHOLD);
    int center = (analog(centerLinePort) > centerLineFloorValue + LINE_THRESHOLD);
    int right = (analog(centerLinePort) > rightLineFloorValue + LINE_THRESHOLD);
    
    if(center)
      {
        if(right)
          {
            drive(100, 50);
            lineFollowState = LINE_FOLLOW_RIGHT;
        }
        else if(left)
          {
            drive(50, 100);
            lineFollowState = LINE_FOLLOW_LEFT;
        }
        else
        {
            drive(100, 100);
        }
    }
    else if(left)
      {
        drive(0, 100);
        lineFollowState = LINE_FOLLOW_LEFT;
    }
    else if(right)
      {
        drive(100, 0);
        lineFollowState = LINE_FOLLOW_RIGHT;
    }
    else
      {
        if(lineFollowState == LINE_FOLLOW_RIGHT)
          drive(100, 0);
        else if(lineFollowState == LINE_FOLLOW_LEFT)
          drive(0, 100);
    }
}
// Follows line for a given distance based on encoders
void FollowFor(int distance, int left, int center, int right)
{
    setEncoder(leftEncoder, 0);
    setEncoder(rightEncoder, 0);
    while(getEncoder(leftEncoder) < distance) followLine(left, center, right);
}*/
void FollowHeading(int distance, int direction, int angle)
{
    drive(100 * direction, 100 * direction);
    setEncoder(leftEncoder, 0);
    setEncoder(rightEncoder, 0);
    while(getEncoder(leftEncoder) < distance)
      {
        while(!gps_get_data());
        if(gps_heading < angle - 2)
          drive(50 * direction, 100 * direction);
        else if(gps_heading < angle - 1)
          drive(80 * direction, 100 * direction);
        else if(gps_heading > angle + 2)
          drive(100 * direction, 50 * direction);
        else if(gps_heading > angle + 1)
          drive(100 * direction, 80 * direction);
        else
        drive(100 * direction, 100 * direction);
    }
    drive(0, 0);
}
void HeadingToLine(int floorValue, int angle, int direction)
{
    drive(100 * direction, 100 * direction);
    setEncoder(leftEncoder, 0);
    setEncoder(rightEncoder, 0);
    while((analog(centerLinePort) < floorValue + LINE_THRESHOLD))
      {
        while(!gps_get_data());
        if(gps_heading < angle - 2)
          drive(50 * direction, 100 * direction);
        else if(gps_heading < angle - 1)
          drive(80 * direction, 100 * direction);
        else if(gps_heading > angle + 2)
          drive(100 * direction, 50 * direction);
        else if(gps_heading > angle + 1)
          drive(100 * direction, 80 * direction);
        else
        drive(100 * direction, 100 * direction);
    }
    drive(0, 0);
}
void TurnToHeading(int angle)
{
    int initial;
    // Wait for data
    printf("Turning...\n");
    while(!gps_get_data());
    initial = gps_heading;
    printf("Got data, initial = %d\n", initial);
    if (initial < angle) {
        drive(-100, 100);
        while (gps_heading < angle)
            {
              while (!gps_get_data());
              printf("heading=%d\n",gps_heading);
          }
    } else if (initial > angle) {
        drive(100, -100);
          while (gps_heading > angle)
            {
              while (!gps_get_data());
              printf("heading=%d\n",gps_heading);
          }
    }
    drive(0,0);

}
